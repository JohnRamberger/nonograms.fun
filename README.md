# nonograms.fun
 nonograms.fun is a website that generates and corrects nonogram puzzles of any size and difficulty. 
 ## About
 I originally started this project as a way to learn web development while also satistying my curiosity with nonograms. I was introduced to nonograms in a club meeting for the math honor society at my high school, where another student attempted to create an algorithm to solve nonograms. While I never fully completed an algorithm to solve nonograms, I managed to create an algorithm to generate random nonogram puzzles of specified dimensions and difficulties while also creating an algorithm to check the completion of a nonogram puzzle (which is necessary due to most nonograms having multiple solutions). 
 ## Deveopment
 I started this project as a learning opportunity not only to look at the science behind nonogram puzzles, but also to learn how to procedurally generate puzzles while displaying them in an efficient way in the browser. After finishing the project, I decided to expand it by adding a MySQL database with the hosting service I was using to allow users to save their nonograms to complete at a later time (nobody has the time to complete a 25x25 nonogram in one sitting). By doing this, I learned how to connect a frontend webpage to a backend database using PHP and AJAX through jQuery. I also implement Google OAuth to allow guests to login via their Google account. 
## How does it work?
The user first selects the dimensions of the puzzle (any # by # combination) and the difficulty they want, which is saved in the page's cookies in case of a page reload. The webpage then generates a grid using the dimensions given, and picks random squares using an algorithm based on the difficulty. Next, the grid is converted into standalone text by separating the grid into rows and columns, using 0s for empty cells and 1s for filled in cells. These values are then put into 2 arrays, one for the rows and one for columns, and are used to generate the hints for each row and column. Once the arrays are generated, a for loop is used to iterate over each row/column to convert the "binary-like" code into hints, which are then inserted into the DOM of the html in their correct position. 
The process of checking for the correct solution is much easier than the process of generating the puzzle. After the puzzle is generated, the puzzle data is saved for access later when solving. In order to check the user's work, the website converts the grid into a psuedo "binary" code once again, which is then compared to the actual puzzle. It's that simple!
